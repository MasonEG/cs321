//START MAIN CODE

//SET VARS FOR BUILDREVERSE
ADDI X0, XZR, #16 //ARRAY STARTS AT 0
ADDI X1, XZR, #20 //ARRAY COUNT IS 10


BL BUILDREVERSE

ADDI X0, XZR, #16     //ARRAY STARTS AT 0 //SET VARS FOR SEARCH SMALLEST
ADDI X1, XZR, #20 //ARRAY COUNT IS 10 

BL SELECTIONSORT
ESS:


ADDI X0, XZR, #16
ADDI X1, XZR, #20
ADDI X2, XZR, #4
BL ITERATIVEBINARYSEARCH
ADD X25, XZR, X3

ADDI X0, XZR, #16
ADDI X1, XZR, #0
ADDI X2, XZR, #20
ADDI X3, XZR, #4
BL RECURSIVEBINARYSEARCH
ERBS:
ADD X26, XZR, X4


BL TERMINATE
 //END MAIN CODE


MULTIPLY: //X0 AND X1 ARE THE PARAMS, X3 IS THE RESULT
    SUBI SP, SP, #8 //MAKE SPACE ON THE STACK
    STUR LR, [SP, #0] //STORE LR ON THE STACK
    ADD X3, XZR, XZR
    BL MULTIPLYLOOP
    MULTIPLYLOOP:
        SUBI X0, X0, #1
        ADD X3, X3, X1
        CBNZ X0, MULTIPLYLOOP
        LDUR LR, [SP, #0] //PULL OUT THE VALUE OF LR WE WANT
        BR LR


BUILDREVERSE: //X0 IS ARRAY STARTING POINT, X1 IS LENGTH
    SUBI SP, SP, #8 //MAKE SPACE ON THE STACK
    STUR LR, [SP, #0] //STORE LR ON THE STACK
    BL BUILDREVERSELOOP
    BUILDREVERSELOOP:
        //DUMP
        STUR X1, [X0, #0]
        SUBI X1, X1, #1
        ADDI X0, X0, #8
        CBNZ X1, BUILDREVERSELOOP
        LDUR LR, [SP, #0] //PULL OUT THE VALUE OF LR WE WANT
        BR LR

SEARCHSMALLEST: //X0 is arr pointer, X1 is search duration, X3 is the result
    SUBI SP, SP, #8 //MAKE SPACE ON THE STACK
    STUR LR, [SP, #0] //STORE LR ON THE STACK

    ADD X9, XZR, X0 //SMALLEST ADDRESS
    ADD X10, XZR, XZR //INDEX OF SMALLEST
    ADDI X11, X9, #0 //CURRENT ADDRESS
    ADDI X12, XZR, #0 //CURRENT INDEX
    LDUR X13, [X9, #0] //CURRENT SMALLEST VALUE
    SUBI X1, X1, #1 // (WE ALREADY WENT THROUGHT THE 1ST ELEMENT)
    
    SEARCHSMALLESTLOOP:
        CBZ X1, SEARCHSMALLESTEXIT 
        ADDI X11, X11, #8 //UPDATE ADDRESS
        ADDI X12, X12, #1 //UPDATE INDEX
        SUBI X1, X1, #1 //DECREMENT LOOPCOUNT
        LDUR X14, [X11, #0] //LOAD CURRENT VALUE
        SUBS X27, X14, X13
        B.GT SEARCHSMALLESTLOOP
        ADD X10, XZR, X12 //UPDATE SMALLEST INDEX
        ADD X9, XZR, X11 //UPDATE SMALLEST ADDRESS
        ADD X13, XZR, X14 ///UPDATE SMALLEST VALUE
        BL SEARCHSMALLESTLOOP

    SEARCHSMALLESTEXIT:
        LDUR LR, [SP, #0] //PULL OUT THE VALUE OF LR WE WANT    
        ADD X3, XZR, X10
        BR LR

        
SELECTIONSORT: //X0 IS THE ADDRESS, X1 IS THE LENGTH
    SUBI SP, SP, #8 //MAKE SPACE ON THE STACK
    STUR LR, [SP, #0] //STORE LR ON THE STACK
    
    ADD X19, X1, XZR //SETUP X19 AS LENGTH
    ADD X20, XZR, X0 // STORE THE CURRENT ADDRESS IN X20
    ADD X21, XZR, XZR //SET UP X21 AS THE INDEX
    ADD X23, XZR, X0 //STORE THE BASE ADDRESS IN X23

    SELECTIONSORTLOOP:
        CBZ X19, EXITSELECTIONSORT
        ADD X0, XZR, X20 //SET VARS FOR SEARCH SMALLEST METHOD
        ADD X1, XZR, X19
        BL SEARCHSMALLEST //CALL SEARCH SMALLEST, SMALLEST INDEX SHOULD BE ON 
        ADD X22, X3, X21 //SET X22 TO THE INDEX OF THE SMALLEST + INDEX]
        LSL X0, X22, #3
        ADD X0, X0, X23
        ADD X1, XZR, X20 //STORE CURRENT ADDRESS IN X1
        BL SWAP //SWAP EM
        ADDI X21, X21, #1 //ADD 1 TO INDEX
        ADDI X20, X20, #8 //MOVE TO THE NEXT ADDRESS IN THE ARRAY
        SUBI X19, X19, #1 //DECREMENT THE LENGTH COUNTER
        BL SELECTIONSORTLOOP

    EXITSELECTIONSORT:
        LDUR LR, [SP, #0] //LOAD LR FROM THE STACK POINTER
        PRNT LR
        BL ESS


SWAP:
    LDUR X10, [X0, #0]
    LDUR X11, [X1, #0]
    STUR X11, [X0, #0]
    STUR X10, [X1, #0]

    BR LR

ITERATIVEBINARYSEARCH: //X0 IS START, X1 IS LENGTH, X2 IS TARGET, X3 IS RESULT
    SUBI SP, SP, #8 //MAKE SPACE ON THE STACK
    STUR LR, [SP, #0] //STORE LR ON THE STACK

    ADD X8, XZR, X1 //STORE START ADDRESS IN X8
    ADD X9, XZR, XZR //START STORED AT X9
    ADD X10, XZR, X1 //END STORED AT X10
    ADD X11, X9, X10 //CALCULATE AND STORE MID INDEX AT X11
    LSR X11, X11, #1 //DIVIDE START + END BY 2
    ADD X12, XZR, X2 //STORE TARGET AT X12

    BL ITERATIVEBINARYSEARCHLOOP

    ITERATIVEBINARYSEARCHLOOP:
        SUBS X27, X10, X9 //IF THE ARR DOESN'T CONTAIN TARGET
        B.LE EXITITERATIVEBINARYSEARCH

        LSL X13, X11, #3 //ADDRESS OF MID AT X13
        ADD X13, X0, X13
        LDUR X14, [X13, #0] //VALUE OF MID AT X18
        PRNT X14

        SUBS X27, X14, X12 //CHECK IF MID == TARGET
        B.EQ EXITITERATIVEBINARYSEARCH
        B.GT ITERATIVEBINARYSEARCHUPDATEEND
        B.LT ITERATIVEBINARYSEARCHUPDATESTART
    
    ITERATIVEBINARYSEARCHUPDATEEND:
        SUBI X10, X11, #1 //UPDATE END INDEX
        ADD X11, X9, X10 //CALCULATE AND STORE MID INDEX AT X11
        LSR X11, X11, #1 //DIVIDE START + END BY 2
        BL ITERATIVEBINARYSEARCHLOOP
    
    ITERATIVEBINARYSEARCHUPDATESTART:
        ADDI X9, X11, #1 //UPDATE START INDEX
        ADD X11, X9, X10 //CALCULATE AND STORE MID INDEX AT X11
        LSR X11, X11, #1 //DIVIDE START + END BY 2
        BL ITERATIVEBINARYSEARCHLOOP
    
    EXITITERATIVEBINARYSEARCH:
        ADD X3, XZR, X11
        LDUR LR, [SP, #0] //PULL OUT THE VALUE OF LR WE WANT
        BR LR

RECURSIVEBINARYSEARCH: //X0 IS ARRAY POINTER, X1 IS START INDEX, X2 IS END INDEX, X3 IS TARGET VALUE, X4 IS THE RESULT
    SUBS X27, X1, X2
    B.GT RECURSIVEBINARYSEARCHEXIT

    ADD X8, X1, X2 //SET UP X8 AS THE MID INDEX
    LSR X8, X8, #1

    LSL X9, X8, #3 //SET UP VALUE OF MID AT X9
    ADD X9, X9, X0
    LDUR X9, [X9, #0]
    
    SUBS X27, X9, X3
    B.EQ RECURSIVEBINARYSEARCHEXIT
    B.LT RECURSIVEBINARYSEARCHUPDATESTART
    B.GE RECURSIVEBINARYSEARCHUPDATEEND

    
    RECURSIVEBINARYSEARCHUPDATESTART:
    ADDI X1, X8, #1
    BL RECURSIVEBINARYSEARCH

    RECURSIVEBINARYSEARCHUPDATEEND:
    SUBI X2, X8, #1
    BL RECURSIVEBINARYSEARCH

    RECURSIVEBINARYSEARCHEXIT:
    ADD X4, XZR, X8
    BL ERBS

TERMINATE:
    SUB X0, X25, X26
    ADD X1, XZR, XZR
    STUR X0, [X1, #0]
    DUMP


